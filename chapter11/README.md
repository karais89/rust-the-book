# 챕터11. 자동화 테스트 작성하기

- 러스트는 자동화된 소프트웨어 테스트의 작성을 언어차원 에서 제공한다.

## 학습 내용

- 러스트의 테스트 메커니즘이 어떻게 동작하는지 설명한다.
- 테스트를 작성하는데 필요한 애노테이션과 매크로, 기본 동작과 테스트의 실행에 필요한 옵션들을 알아본다.
- 단위 테스트와 통합 테스트를 구분하는 방법을 소개한다.

## 느낀점
- 현대 언어에서 제공할 수 있는 부분은 전부 제공하는 것으로 보인다.
- 항상 모든 개발 서적을 보면 중요시하는 유닛 테스트. 좋은 것은 알겠는데 실제 적용은 좀 힘들긴 하다.

## 주요 내용

### 11.1 테스트의 작성

테스트 함수의 본문은 주로 아래 세가지 동작을 수행한다.
- 필요한 데이터나 상태를 설정한다.
- 테스트할 코드를 실행한다.
- 의도한 결과가 출력되는지 검증한다.

테스트는 test 특성을 적용한 러스트 함수이다. 특성이란 러스트 코드에 대한 메타 데이터이다.
`cargo test` 명령어를 통해 테스트 실행 가능.
- panic!을 통해 테스트 실패 상황을 만들 수 있음
- assert!를 통해 true, false 비교 가능
- assert_eq!와 assert_ne! 매크로로 두 값을 비교 가능
- should_panic 매크로로 패닉의 발생 여부 검증 가능

### 11.2 테스트 실행 제어하기
- cargo test 명령은 테스트 모드의 코드를 컴파일하고 결과 테스트 바이너리를 실행한다.
- 여러개의 테스트를 실행할 때는 기본적으로 스레드를 이용해 병렬로 실행한다.
    - 테스트를 병렬로 실행하기 원하지 않으면 `cargo test -- --test-threads=1`
- 성공한 테스트의 println! 값도 출력하고 싶다면
    - `cargo test -- --nocapture`
- 하나의 테스트만 실행하고 싶다면
    - `cargo test <함수이름>`
    - `cargo test one_hundred`
- 여러개의 테스트를 실행하고 싶다면
    - `cargo test add`
    - 이름에 add가 포함된 테스트만 실행한다.
- 특정 테스트 제외하고 싶다면
    - 어노테이션 #[ignore]를 붙인다
    - #[ignore]테스트만 실행하고 싶다면 `cargo test -- --ignored` 명령어 입력

### 11.3 테스트의 조직화
- 단위 테스트와 통합 테스트
    - 단위 테스트: 작고 집중적이며 한 번에 하나의 모듈을 독립적으로 테스트하고 비공개 인터페이스를 테스트할 수도 있다.
    - 통ㅎ바 테스트: 완전히 라이브러리 이외의 것을 테스트하는 것으로 외부 코드와 같은 방법으로 테스트 코드를 사용하며, 공개 인터페이스만을 테스트할 수 있고 하나의 테스트가 여러 개의 모듈을 활용할 수 있다.
- 단위 테스트는 라이브러리를 별개로 테스트하는 방법, 통합 테스트는 다른 모듈과 함께 라이브러리를 테스트하는 방법으로 라이브러리가 의도대로 동작하는 것을 검증하기 위해 두 종류의 테스트를 모두 작성하는 것이 매우 중요하다.
- 단위 테스트
    - 목적: 코드의 각 단위를 나머지 코드와는 독립적으로 테스트해서 코드가 의도대로 동작하는지를 빠르게 판단
    - 보통 src 디렉터리의 각 파일에 테스트할 코드와 함께 작성한다.
    - cfg 특성은 (configuration)의 약자
    - 비공개 함수의 테스트도 가능하다.(러스트에서는 단위테스트가 같은 모듈에 존재하기 때문)
- 통합 테스트
    - 완전히 라이브러리의 영역 바깥에서 진행된다.
    - 라이브러리의 공개 API만 호출할 수 있다.
    - 목적: 라이브러리의 여러 부분이 올바르게 동작하는지 확인
    - 통합 테스트의 커버리지 역시 매우 중요하다.
        - 커버리지란 시스템 또는 소프트웨어의 테스트를 논할 때 얼마나 테스트가 충분한가를 나타낸 것이다
    - tests 디렉터리를 생성한다.
    - 라이브러리 프로젝트만 통합 테스트가 가능하다.