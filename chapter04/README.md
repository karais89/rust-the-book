# 챕터4. 소유권

소유권은 러스트의 독특한 기능 중 하나이다.
가비지 컬렉터에 의존하지 않고도 메모리 안전성을 보장하려는 러스트만의 해법이다.

## 학습 내용
- 소유권 (ownership)
- 대여 (borrowing)
- 슬라이스 (slice)
- 러스트의 메모리 관리 방법

## 느낀점
- 러스트의 독특한 기능 중 하나. 모든 것들을 컴파일 단계에서 판단하고, 가비지 컬렉터가 없는 언어 만큼의 속도를 낼 수 있게 한다.
- 레퍼런스 카운팅 기법이랑은 또 다른 방법이라고 생각해야 되나?
- 이동은 좀 특이하다. 얕은 복사, 깊은 복사 개념이 아닌 아예 해당 변수(복사한)를 사용하지 못하게 된다.
- 러스트는 데이터 경합 부분도 컴파일 상에서 파악이 가능하다.
- 댕글링 포인터도 러스트에서는 컴파일 단계에서 허용하지 않음.
- 사람의 실수에 의한 부분을 사전에 차단하는 방식이 독특하다고 느꼈다.
    - 그런데 이로 인해 컴파일을 통과하기 어려운 부분도 분명 존재하고, 어느정도 코드의 제약은 있는 것으로 보인다. ~(무지성 코딩 불가)~

## 주요 내용
- 소유권은 러스트의 핵심 기능이다. 이해하기 어렵지만 반드시 이해하고 넘어가야 한다.
- 소유권은 이해하기 어렵지만, 익숙해질수록 더 안전하며 효율적인 코드를 작성할 수 있도록 해준다.
- 스택과 힙에 대한 간략한 설명
    - 스택 = 고정된 길이의 데이터 = 바로 접근 가능
    - 힙 = 고정적이지 않은 길이의 데이터 = 포인터
    - 스택이 힙 보다 빠르다. (스택은 힙에 비해 별다른 연산이 필요 없다.)
- 러스트의 소유권은 힙 데이터를 관리하기 위해 존재한다.
- 소유권 규칙
    - 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있다.
    - 특정 시점에 값의 소유자는 단 하나뿐이다.
    - 소유자가 범위를 벗어나면 그 값은 제거된다.
- 변수가 스코프 범위를 벗어나면 drop 함수가 자동으로 호출된다.
    - RAII와 유사하다.
- 이동
    - 함수에서도 마찬가지로 작동한다.
## 4.2 참조와 대여
- 앰퍼샌드(ampersands, & 기호)가 바로 참조이며, 이를 사용하면 소유권을 가져오지 않고도 값을 참조할 수 있다.
    - 참조의 반대는 역참조라고 하며 역참조 연산자(*)에 의해 동작한다.
- 함수 매개변수로 참조를 전달하는 것을 대여(borrowing)라고 한다.
    - 참조는 기본적으로 불변으로 수정 불가하다.
    - &mut s와 같이 가변참조를 생성하면 값 변경이 가능하다.
- 가변 참조
    - 제약사항: 특정 범위 내의 특정 데이터에 대한 가변 참조는 오직 한 개만 존재해야 한다.
- 가변 참조의 제약사항으로 인해 데이터 경합을 컴파일 시점에 방지할 수 있다.
    - 둘 혹은 그 이상의 포인터가 동시에 같은 데이터를 읽거나 쓰기 위해 접근할 때
    - 최소한 하나의 포인터가 데이터를 쓰기 위해 사용될 때
    - 데이터에 대한 접근을 동기화할 수 있는 메커니즘이 없을 때
- 러스트는 데이터 경합이 발생하는 코드의 컴파일을 허용하지 않는 방식으로 이 문제를 예방한다.
- 불변 참조와 가변 참조를 섞어서 사용할때도 비슷한 규칙이 적용된다.
    - 불변 참조의 사용 중일때는 가변 참조를 사용할 수 없다.
- 댕글링 포인터 (죽은 참조)
    - 댕글링 포인터도 러스트가 방지함.
- 참조에 대한 규칙
    - 어느 한 시점에 코드는 하나의 가변 참조 또는 여러 개의 불변 참조를 생성할 수는 있지만, 둘 모두를 생성할 수는 없다.
    - 참조는 항상 유효해야 한다.