# 챕터2. 숫자 맞히기 게임의 구현

## 학습 내용
- 실제로 동작하는 프로그램 작성 한다.
- let, match, 메서드, 연관 함수, 외부 크레이트의 사용법등을 간략히 배운다.

## 느낀점
- 2장 부터 바로 실전 프로젝트로 학습을 하는 부분은 굉장히 좋은 것 같다.
- 러스트는 언어 자체가 다른 언어와 다른 점이 많다. 기본적으로 변수는 변경 불가능 하다.(해당 사양으로 인해 휴먼 에러로 인한 버그 및 컴파일 속도의 향상 등의 영향을 줄 수 있다)
- 오류 처리 또한 다른 언어와 다르게 (try-catch) 별도의 방법으로 에러 처리를 진행한다. 이 부분은 확실히 더 나은 부분으로 보인다. golang도 이런 에러 처리가 괜찮다고 생각했는데, 이 부분은 개인적으로 rust 부분이 더 좋아 보인다. (그런데 거의 비슷하다)
- 러스트의 매크로 기능은 괜찮아 보이긴 하는데 실제 구현 자체도 괜찮을지는 아직 모르겠다. 다른 라이브러리등을 보면 매크로 기능등을 많이 사용하는 것 같긴하다.
- Cargo는 코드가 변경되지 않았으면 그 사실을 알고 코드를 다시 컴파일 하지 않는다. 의존 패키지의 경우도 이미 다운로드 받은 파일은 다시 다운로드 받지 않는다. ~(Cargo는 모든 걸 알고 있다.)~
- 크레이트 별로 모든 것들이 쪼개져 있고, 해당 크레이트등도 종류도 많아 좋긴 하지만, 결국 사용 방법을 찾는 부분은 좀 불편하다. (커뮤니티가 다른 언어에 비해서 없어서 불편한 부분)

## 주요 내용
- Cargo.toml의 구조가 조금 변경되었다. authors, edition 정보가 없어졌다.
- io 라이브러리 가져오기 `use std::io;`
- 러스트는 모든 프로그램의 프렐류드(Prelude)에서 기본적으로 단 몇개의 타입만을 가져온다.
- let은 변수를 생성하는 구문이다.
    - 러스트에서는 기본적으로 변수의 값을 변경할 수 없다. ~변수 자체가 이름을 변경할 수 있는게 변수인데~
    - 변수의 값을 변경하려면 mut 키워드를 앞에 붙인다.
    ```rust
    let foo = 5;
    let mut bar = 5;
    ```
- 러스트에서는 연관 함수 제공(다른 언어에서의 정적 함수) 제공
- & 기호는 참조 타입. c++의 레퍼런스와 거의 같은 기능으로 인식함.
- Result 타입으로 오류 처리
    - Result 타입은 일종의 열거자 Ok와 Err이 있다.
    - expect 메서드는 프로그램의 실행을 종료하고 expect 메서드에 인수로 전달한 메세지를 표시한다.
- rand 크레이트
    - 난수 제공 크레이트
    - Cargo.html에 크레이트를 추가한다.
    - Cargo는 버전을 시멘틱 버전을 사용한다.
- cargo.lock 파일은 처음 빌드시 등록된 버전을 사용할 수 있도록 한다.
- 새버전의 크레이트로 업그레이드도 물론 가능
    - `cargo update`
    - 버전의 경우는 하지만 시멘틱 버전 기준을 따르기 때문에 마이너 버전 쪽만 업데이트 된다. 맨 끝의 버전
- 크레이트 사용 방법은 각 크레이트의 문서를 참고해야 한다.
    - `cargo doc --open` 등으로 모든 의존 패키지의 문서도 확인 가능하다.